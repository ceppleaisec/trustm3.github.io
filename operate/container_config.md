---
---

- TOC
{:toc}

## Container configuration

All containers currently available are defined in the configuration files in the form `<container-uuid>.conf` in the '/data/cml/containers/' folder. The `<container-uuid>` is a Universal Unique Identifier provided in five character groups separated by hyphens, e.g., 11111111-1111-1111-1111-111111111111. 

A full container configuration file includes the following the following (optional) fields:

```protobuf
// user configurable, non unique
required string name
// name of GuestOS, e.g. idsos
required string guest_os
// (minimal) version of GuestOS; will be updated if container is started with a more recent GuestOS version.
optional uint64 guestos_version
// complete image sizes from GuestOS for user partitions
repeated ContainerImageSize image_sizes
optional uint32 ram_limit [ default = 1024 ] // unit = MBytes
required fixed32 color
// type of container, e.g. KVM or CONTAINER
required ContainerType type [ default = CONTAINER ]
repeated string init_env	// environment variables
// use user_namespace
optional bool userns [default = true]
// Flags indicating the allows for containers:
optional bool allow_autostart [default = false]
// a list of strings wich contain the features image prefix name without .img
repeated string feature_enabled
optional string dns_server
optional bool netns [default = true]
// a list of network interfaces assigned to this container
repeated string net_ifaces
// a list of devices explicitely allowed for this container
repeated string allow_dev
// a list of devices exclusively assigned to this container
repeated string assign_dev
// list of virtual network interface configuration
repeated ContainerVnetConfig vnet_configs
// list of usb devices assigned to this container 
repeated ContainerUsbConfig usb_configs
// number of pipes from c0 to this container
repeated string fifos
}
```

The original Protobuf formatted file can be found [here](https://github.com/trustm3/device_fraunhofer_common_cml/blob/trustx-master/daemon/container.proto).

A typical container configuration must define container name, guest OS name and version. Optionally it defines the container's vnet configuration and assigned USB devices.
The veth endpoints within the rootns are autogenerated by the cmld

The following example depicts a configuration which includes two virtual ethernet interfaces and one USB device assigned to the container:

```
name: "core0"
guest_os: "idsos"
guestos_version: 1
color: 0
type: CONTAINER
vnet_configs {
  if_name: "eth0" 
	configure: false
	if_rootns_name: "r_0"
}
vnet_configs {
	if_name: "eth1"
	configure: false
	if_rootns_name: "r_1"
}
usb_configs {
  id: "04e6:5816"
  serial: "5511747600021"
  assign: true
}
```

Accessing those files directly is not possible from core0 container.
Only in development builds with enabled `'debug-tweeks'`, you can access this
through CML shell on tty12.

Intended control of container configuration is gained through the control interface from within
core0 container.
The corresponding commands of the control tool are `create`, `config` and `update_config`


**create** uses a container.config skeleton as shown above, and writes it to corresponding
config files in `/data/cml/containers/` with a random uuid. The corresponding created config
is also responded back to core0 through the control interface.

**config** requests the configuration from an existing container. Similar to
the answer of create. You can write it to some location inside core0 to edit it.

**update_config**  writes back an edited config or just overwrites the existing
config by the provided skeleton.