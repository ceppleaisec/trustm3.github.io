---
---

- TOC
{:toc}

# Container configuration

## Run-time container configuration
All containers currently available are defined in the configuration files in the form `<container-uuid>.conf` in the '/data/cml/containers/' folder. The `<container-uuid>` is a Universal Unique Identifier provided in five character groups separated by hyphens, e.g., 11111111-1111-1111-1111-111111111111.

Accessing those files directly is not possible from core0 container.
Only in development builds with enabled `'debug-tweeks'`, you can access this
through CML shell on tty12.



A full container configuration file includes the following (optional) fields:

```protobuf
// user configurable, non unique
required string name
// name of GuestOS, e.g. idsos
required string guest_os
// (minimal) version of GuestOS
// will be updated if container is started with a more recent GuestOS version.
optional uint64 guestos_version
// complete image sizes from GuestOS for user partitions
repeated ContainerImageSize image_sizes
optional uint32 ram_limit [ default = 1024 ] // unit = MBytes
required fixed32 color
// type of container, e.g. KVM or CONTAINER
required ContainerType type [ default = CONTAINER ]
repeated string init_env	// environment variables
// use user_namespace
optional bool userns [default = true]
// Flags indicating the allows for containers:
optional bool allow_autostart [default = false]
// a list of strings wich contain the features image prefix name without .img
repeated string feature_enabled
optional string dns_server
optional bool netns [default = true]
// a list of network interfaces assigned to this container
repeated string net_ifaces
// a list of devices explicitely allowed for this container
repeated string allow_dev
// a list of devices exclusively assigned to this container
repeated string assign_dev
// list of virtual network interface configuration
repeated ContainerVnetConfig vnet_configs
// list of usb devices assigned to this container 
repeated ContainerUsbConfig usb_configs
// number of pipes from c0 to this container
repeated string fifos
}
```

The full-blown protocol specification can be found [here](https://github.com/trustm3/device_fraunhofer_common_cml/blob/trustx-master/daemon/container.proto) as protobuf-text formatted file.


### Parameter ```image_sizes```
The ```image_sizes``` parameter defines the sizes of user partitions of the GuestOS. Its type ```ContainerImageSize``` is defined as follows:

```protobuf
message ContainerImageSize {
	required string image_name = 1; // virtual name of the image file in guestos
	required uint64 image_size = 2; // size (bytes) of the image file
	optional string image_file = 3; // name of alternate image file which overwrites image_name of guestos config
}
```
Valid configuration depends on the choice of the [GuestOS configuration](operate/guestos_config) and its ```mounts``` parameters.

### Parameter ```net_ifaces```
The repeated ```net_ifaces``` parameter list host network interfaces that are assigned to the container. The interfaces are identified by their name as it is printed the ``` ip link``` command.

### Parameter ```allow_dev``` and ```assign_dev```
The repeated ```allow_dev``` parameter list host devices which the container is allowed to access.
The repeated ```assign_dev``` parameter list host devices which the container is allowed to access.
Devices are identified using the **cgroups** syntax.

### Parameter ```vnet_configs```
The repeated ```vnet_configs```parameter list virtual network interface configuration.
They are of type ```ContainerVnetConfig``` which is defined as

```protobuf
message ContainerVnetConfig {
	required string if_name = 1; // name of virtual veth endpoint in container
	required bool configure = 2; // should cmld configure the interface or leav it unconfigured
	optional string if_rootns_name = 3; // name of virtual veth endpoint in rootns (will be autogenerated by cmld)
	optional string if_mac = 4; // mac of virtual veth endpoint inside container (will be autogenerated)
}
```

### Parameter ```usb_configs```
The repeated ```usb_config``` parameter list host USB devices which are assigned to the container.
Their type is 

```protobuf
message ContainerUsbConfig {
	required string id = 1;
	required string serial = 2;
	required bool assign = 3 [default = false];
}
```
TODO

### Parameter ```fifos```
TODO





### Example container configuration
TODO
The following example depicts a run-time configuration which includes two virtual ethernet interfaces and one USB device assigned to the container:

```
name: "core0"
guest_os: "idsos"
guestos_version: 1
color: 0
type: CONTAINER
vnet_configs {
  if_name: "eth0" 
	configure: false
	if_rootns_name: "r_0"
}
vnet_configs {
	if_name: "eth1"
	configure: false
	if_rootns_name: "r_1"
}
usb_configs {
  id: "04e6:5816"
  serial: "5511747600021"
  assign: true
assign_dev: "c 4:1 rwm"

TODO: - assign_dev
      - allow_dev (cgroups syntax)
      - net_ifaces (einfach name, wie ip link)
      - image_sizes
}
```

## Container configuration skeleton
A new container is created using the **create** command and supplying a configuration skeleton to it.
While the above described run-time configuration of a container is syntactically compatible with the skeleton configuration they are semantically distinct and should not be confused!
The user specifies the skeleton configuration according to his needs but ultimately the CML will generate the run-time configuration.
The CML layer may modify the skeleton (e.g. overwrite the provided ```if_rootns_name``` with the next free ```r_*```) and/or enhance it with non user provided default parameters!

## Container configuration management
Intended control of container configuration is gained through the control interface from within
core0 container.
The corresponding commands of the control tool are `create`, `config` and `update_config`
TODO: keine skeleton beschreibung, sondern config adaptiert von CML

**create** uses a container.config skeleton as shown above, and writes it to corresponding
config files in `/data/cml/containers/` with a random uuid. The corresponding created config
is also responded back to core0 through the control interface.

**config** requests the configuration from an existing container. Similar to
the answer of create. You can write it to some location inside core0 to edit it.

**update_config**  writes back an edited config or just overwrites the existing
config by the provided skeleton.